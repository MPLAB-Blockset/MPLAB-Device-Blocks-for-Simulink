<!DOCTYPE html>
<html>
<head>
    <title>MCHP PGA - MCHP Blockset Documentation</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../../assets/css/navigation.css">
    <script src="../../assets/js/navigation.js"></script>
</head>
<body>
    <!-- Mobile Navigation Toggle -->
    <button class="nav-toggle" aria-label="Toggle navigation">☰</button>

    <!-- Left Navigation Panel -->
    <nav class="doc-nav-container">
        <div class="doc-nav-header">
            <a href="../../index.html">MCHP Blockset Docs</a>
        </div>
        <ul class="doc-nav-menu">
            <li class="nav-item">
                <a href="../../index.html" class="nav-link">Home</a>
            </li>

            <!-- Getting Started Section -->
            <li class="nav-item">
                <div class="nav-category">Getting Started <span class="nav-category-icon">▼</span></div>
                <ul class="nav-list">
                    <li><a href="../../getting_started/overview.html" class="nav-link">Overview</a></li>
                    <li><a href="../../getting_started/installation.html" class="nav-link">Installation</a></li>
                    <li><a href="../../getting_started/quick_start.html" class="nav-link">Quick Start</a></li>
                    <li><a href="../../getting_started/board_templates.html" class="nav-link">Board Templates</a></li>
                    <li><a href="../../getting_started/supported_devices.html" class="nav-link">Supported Devices</a></li>
                </ul>
            </li>

            <!-- User Guide Section -->
            <li class="nav-item">
                <div class="nav-category">User Guide <span class="nav-category-icon">▼</span></div>
                <ul class="nav-list">
                    <li><a href="../../user_guide/index.html" class="nav-link">User Guide Overview</a></li>
                    <li><a href="../../user_guide/code_generation.html" class="nav-link">Code Generation</a></li>
                    <li><a href="../../user_guide/external_mode.html" class="nav-link">External Mode</a></li>
                </ul>
            </li>

            <!-- Block Reference Section -->
            <li class="nav-item">
                <div class="nav-category">Block Reference <span class="nav-category-icon">▼</span></div>
                <ul class="nav-list">
                    <li><a href="../../block_reference/index.html" class="nav-link">Block Reference Overview</a></li>
                </ul>
            </li>

            <!-- Examples Section -->
            <li class="nav-item">
                <div class="nav-category">Examples <span class="nav-category-icon">▼</span></div>
                <ul class="nav-list">
                    <li><a href="../../examples/field_weakening.html" class="nav-link">Field Weakening</a></li>
                </ul>
            </li>

            <!-- Release Notes -->
            <li class="nav-item">
                <a href="../../release_notes.html" class="nav-link">Release Notes</a>
            </li>
        </ul>
    </nav>

    <div class="doc-content-wrapper">
    <div class="header">
        <h1>MCHP_PGA - Programmable Gain Amplifier</h1>
        <p>Digitally-controlled gain amplifier with calibration for precision analog signal conditioning</p>
    </div>

    <div class="breadcrumb">
        <a href="../../index.html">Home</a>
        <span>›</span>
        <a href="../index.html">Block Reference</a>
        <span>›</span>
        <a href="analog.html">Analog Blocks</a>
        <span>›</span>
        <span>PGA</span>
    </div>

    <div class="container">
        <div class="content-card">
            
    <!-- Block Icon -->
    <div class="block-image">
        <img src="../assets/images/blocks/analog/PGA.svg"
             alt="PGA Block Icon"
             onerror="this.onerror=null; this.src='../assets/images/blocks/analog/PGA.png';">
        <div class="block-image-caption">
            PGA Block Icon
        </div>
    </div>
<h2>Block Overview</h2>
            <p>
                The <strong>MCHP_PGA</strong> block provides access to the Programmable Gain Amplifier (PGA) peripheral available
                in select dsPIC33C, dsPIC33CH, and dsPIC33CK devices. The PGA offers digitally-controlled gain settings with
                calibration capabilities, enabling precision signal conditioning for sensor inputs and ADC front-end applications.
            </p>

            <div class="note">
                <strong>Key Advantages:</strong>
                <ul>
                    <li>Software-configurable gain: 1×, 2×, 4×, 8×, 16×, 32× (device-dependent)</li>
                    <li>Runtime gain adjustment via block input or register write</li>
                    <li>Offset and gain calibration registers for precision measurements</li>
                    <li>Direct connection to DACOUT pins or internal ADC inputs</li>
                    <li>Single-ended or differential input modes</li>
                    <li>Eliminates external amplifier circuits and reduces BOM cost</li>
                </ul>
            </div>

            <h3>Supported Device Families</h3>
            <table class="parameter-table">
                <tr>
                    <th>Family</th>
                    <th>DOS Module</th>
                    <th>PGA Instances</th>
                    <th>Gain Range</th>
                    <th>Output Options</th>
                </tr>
                <tr>
                    <td><strong>dsPIC33C/CH/CK</strong></td>
                    <td><code>DOS_02291_PGA</code></td>
                    <td>2 PGA channels</td>
                    <td>1×, 2×, 4×, 8×, 16×, 32×</td>
                    <td>DACOUT1, DACOUT2, Internal</td>
                </tr>
            </table>

            <div class="info">
                <strong>Output Routing:</strong> PGA outputs can be routed to DACOUT pins (for external ADC or monitoring)
                or kept internal (for direct connection to on-chip ADC). The block automatically configures pin assignments
                based on your selection.
            </div>
        </div>

        <div class="content-card">
            <h2>Operating Modes</h2>

            <h3>1. Single-Ended Input Mode</h3>
            <div class="example">
                <strong>Configuration:</strong>
                <ul>
                    <li><strong>Positive Input (PGAxP):</strong> Signal source connected to PGAxP pin</li>
                    <li><strong>Negative Input (PGAxN):</strong> Grounded (single-ended reference)</li>
                    <li><strong>Gain:</strong> Digitally selectable (2⁰ = 1×, 2¹ = 2×, 2² = 4×, up to 2⁵ = 32×)</li>
                    <li><strong>Output:</strong> V_OUT = Gain × (V_PGAxP - GND)</li>
                    <li><strong>Use Case:</strong> Single-ended sensor signals, voltage measurement</li>
                </ul>
            </div>

            <h3>2. Differential Input Mode</h3>
            <div class="example">
                <strong>Configuration:</strong>
                <ul>
                    <li><strong>Positive Input (PGAxP):</strong> Differential signal high side</li>
                    <li><strong>Negative Input (PGAxN):</strong> Differential signal low side</li>
                    <li><strong>Gain:</strong> Applied to differential voltage</li>
                    <li><strong>Output:</strong> V_OUT = Gain × (V_PGAxP - V_PGAxN)</li>
                    <li><strong>Use Case:</strong> Differential sensor signals, common-mode noise rejection</li>
                </ul>
            </div>

            <h3>3. Cascaded Gain Stages</h3>
            <div class="example">
                <strong>Configuration:</strong>
                <ul>
                    <li><strong>PGA1:</strong> First stage amplification (e.g., 4×)</li>
                    <li><strong>PGA2:</strong> Second stage amplification (e.g., 8×)</li>
                    <li><strong>Total Gain:</strong> 4× × 8× = 32× (beyond single PGA range)</li>
                    <li><strong>Connection:</strong> PGA1_OUT → PGA2_IN (internal or external)</li>
                    <li><strong>Use Case:</strong> Very low-level signals requiring high gain</li>
                </ul>
            </div>
        </div>

        <div class="content-card">
            <h2>Block Parameters</h2>

            <table class="parameter-table">
                <tr>
                    <th>Parameter</th>
                    <th>Options</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td><strong>PGA1Gain</strong></td>
                    <td>
                        • Disabled<br>
                        • Gain 1 (2⁰)<br>
                        • Gain 2 (2¹)<br>
                        • Gain 4 (2²)<br>
                        • Gain 8 (2³)<br>
                        • Gain 16 (2⁴)<br>
                        • Gain 32 (2⁵)
                    </td>
                    <td>
                        Sets the gain for PGA1 channel. Gain is encoded as power of 2 in the GAIN[2:0] field
                        of PGA1CON register. Value written to register is log₂(gain). Disabled mode turns
                        off PGA1 and tri-states the output.
                    </td>
                </tr>
                <tr>
                    <td><strong>PGA1N_pin</strong></td>
                    <td>
                        • Ground (Single-Ended mode)<br>
                        • PGA1N1 / Port / Pin[xx]<br>
                        • PGA1N2 / Port / Pin[xx]<br>
                        • (device-dependent options)
                    </td>
                    <td>
                        Selects the negative input source for PGA1. "Ground" option configures single-ended
                        mode with internal ground reference. Pin options select specific analog input pins
                        for differential mode. SELNI[2:0] register field is automatically configured.
                    </td>
                </tr>
                <tr>
                    <td><strong>PGA1P_pin</strong></td>
                    <td>
                        • PGA1P1 / Port / Pin[xx]<br>
                        • PGA1P2 / Port / Pin[xx]<br>
                        • (device-dependent options)
                    </td>
                    <td>
                        Selects the positive input pin for PGA1. Multiple input pin options allow flexible
                        routing based on PCB layout. SELPI[2:0] register field is automatically configured
                        based on selection.
                    </td>
                </tr>
                <tr>
                    <td><strong>PGA1Output</strong></td>
                    <td>
                        • on (Connect to DACOUT pin)<br>
                        • off (Internal only)
                    </td>
                    <td>
                        Enables output to DACOUT1 pin when "on". PGOEN bit is set to route PGA output to
                        external pin. When "off", output is only available internally (e.g., for ADC input).
                        Reduces pin count when external output not needed.
                    </td>
                </tr>
                <tr>
                    <td><strong>PGA1Gain_BlockInput</strong></td>
                    <td>
                        • on (Dynamic gain control)<br>
                        • off (Fixed gain)
                    </td>
                    <td>
                        When enabled, creates a block input port for runtime gain adjustment. Input accepts
                        uint16 value (0-5) representing 2^x gain. Allows automatic gain ranging or adaptive
                        signal conditioning based on signal amplitude.
                    </td>
                </tr>
                <tr>
                    <td><strong>PGA2Gain</strong></td>
                    <td>
                        (Same options as PGA1Gain)
                    </td>
                    <td>
                        Configuration for second PGA channel (PGA2). Independent gain control allows
                        simultaneous processing of two sensor channels or cascaded gain stages.
                    </td>
                </tr>
                <tr>
                    <td><strong>PGA2N_pin, PGA2P_pin</strong></td>
                    <td>
                        (Similar to PGA1 pins)
                    </td>
                    <td>
                        Input pin selection for PGA2. Pin options are device-specific and displayed
                        dynamically based on available hardware resources.
                    </td>
                </tr>
                <tr>
                    <td><strong>PGA2Output</strong></td>
                    <td>
                        • on (Connect to DACOUT pin)<br>
                        • off (Internal only)
                    </td>
                    <td>
                        Output enable for PGA2. Routes to DACOUT2 pin when enabled. Note: Some devices
                        support DBCC (DACOUT Bridge Connection) to merge DACOUT1 and DACOUT2 outputs.
                    </td>
                </tr>
                <tr>
                    <td><strong>PGA2Gain_BlockInput</strong></td>
                    <td>
                        • on<br>
                        • off
                    </td>
                    <td>
                        Dynamic gain control input for PGA2 (same functionality as PGA1Gain_BlockInput).
                    </td>
                </tr>
                <tr>
                    <td><strong>Fuse_FDEVOPT_DBCC</strong></td>
                    <td>
                        • on (Bridge mode)<br>
                        • off (Independent)
                    </td>
                    <td>
                        Read-only status indicator showing DACOUT Bridge Connection fuse setting from
                        master block. When enabled, DACOUT1 and DACOUT2 are electrically connected.
                        This is a fuse configuration, not controllable from this block.
                    </td>
                </tr>
            </table>

            <div class="warning">
                <strong>Important:</strong> The DBCC (DACOUT Bridge Connection) setting is configured in the master
                configuration block and affects both PGA outputs. When DBCC is enabled, both DACOUT1 and DACOUT2 are
                shorted together, which may affect circuit operation if not designed accordingly.
            </div>
        </div>

        <div class="content-card">
            <h2>Register Configuration</h2>

            <h3>PGAxCON Register (x = 1 or 2)</h3>
            <div class="code-block">
// PGA Control Register
PGAxCON = (PGAEN &lt;&lt; 15) |      // PGA Enable (1 = enabled)
          (PGOEN &lt;&lt; 14) |      // Output Enable (1 = connect to DACOUTx)
          (SELPI &lt;&lt; 11) |      // Positive Input Select [2:0]
          (SELNI &lt;&lt; 8) |       // Negative Input Select [2:0]
          (GAIN &lt;&lt; 0);         // Gain Select [2:0] (0=1×, 1=2×, 2=4×, 3=8×, 4=16×, 5=32×)

// Example: PGA1 with 8× gain, differential input, output enabled
PGA1CON = 0x8B18;  // 1000_1011_0001_1000
// Bit 15 (PGAEN) = 1    → PGA enabled
// Bit 14 (PGOEN) = 0    → Output to DACOUT1
// Bits 13:11 (SELPI) = 001 → Positive input PGA1P1
// Bits 10:8 (SELNI) = 011 → Negative input PGA1N3
// Bits 2:0 (GAIN) = 011 → Gain = 2³ = 8×
            </div>

            <h3>Runtime Gain Update</h3>
            <div class="code-block">
// Dynamic gain adjustment via block input
// Block input port accepts uint16 value representing gain exponent

// Input value 0 → Gain = 2⁰ = 1×
// Input value 1 → Gain = 2¹ = 2×
// Input value 2 → Gain = 2² = 4×
// Input value 3 → Gain = 2³ = 8×
// Input value 4 → Gain = 2⁴ = 16×
// Input value 5 → Gain = 2⁵ = 32×

// Automatic gain ranging example:
if (ADC_Value &lt; 1000) {
    PGA_Gain = 5;  // Increase to 32× for weak signals
} else if (ADC_Value &gt; 3000) {
    PGA_Gain = 0;  // Decrease to 1× for strong signals
} else {
    PGA_Gain = 2;  // 4× for mid-range signals
}
            </div>

            <h3>Pin Configuration</h3>
            <div class="code-block">
// Automatic pin configuration when PGA enabled
// Example for PGA1 with differential input and output:

if (PGA1CONbits.PGAEN) {
    // Configure positive input pin
    TRISx_PGA1P = 1;        // Input direction
    ANSELx_PGA1P = 1;       // Analog mode

    // Configure negative input pin (if not grounded)
    if (SELNI != 0) {
        TRISx_PGA1N = 1;    // Input direction
        ANSELx_PGA1N = 1;   // Analog mode
    }

    // Configure output pin (if enabled)
    if (PGA1CONbits.PGOEN) {
        TRISx_DACOUT1 = 0;  // Output direction
        ANSELx_DACOUT1 = 1; // Analog mode
    }
}
            </div>
        </div>

        <div class="content-card">
            <h2>Application Examples</h2>

            <h3>Example 1: Sensor Signal Conditioning with Fixed Gain</h3>
            <div class="example">
                <strong>Application:</strong> Temperature sensor with 0-100mV output
                <div class="code-block">
// Configuration:
// - PGA1Gain = "Gain 16 (2⁴)"
// - PGA1P_pin = "PGA1P1 / RA0 / Pin[2]" (sensor output)
// - PGA1N_pin = "Ground (Single-Ended mode)"
// - PGA1Output = "off" (internal to ADC)
// - PGA1Gain_BlockInput = "off" (fixed gain)

// Hardware connections:
// - Temperature sensor output (0-100mV) → PGA1P1 (RA0)
// - PGA1 output (internal) → ADC_CH1

// Register configuration:
PGA1CONbits.PGAEN = 1;     // Enable PGA1
PGA1CONbits.PGOEN = 0;     // Internal output only
PGA1CONbits.SELPI = 1;     // PGA1P1 selected
PGA1CONbits.SELNI = 0;     // Grounded (single-ended)
PGA1CONbits.GAIN = 4;      // 2⁴ = 16× gain

// Signal chain:
// Sensor: 0-100mV → PGA (16×) → 0-1.6V → ADC → Digital value
// Full sensor range maps to 0-1.6V ADC input (within 0-3.3V range)
                </div>
            </div>

            <h3>Example 2: Dynamic Gain Control for Wide Input Range</h3>
            <div class="example">
                <strong>Application:</strong> Photosensor with 1000:1 light intensity range
                <div class="code-block">
// Configuration:
// - PGA1Gain = "Gain 1 (2⁰)" (initial setting)
// - PGA1P_pin = "PGA1P1 / RA0 / Pin[2]"
// - PGA1N_pin = "Ground (Single-Ended mode)"
// - PGA1Output = "off"
// - PGA1Gain_BlockInput = "on" ← Enable dynamic gain

// Simulink model:
// [ADC Value] → [Gain Selection Logic] → [PGA Gain Input]
//                                      ↓
//                            Update gain for next sample

// Automatic gain ranging algorithm:
if (ADC_12bit &lt; 512) {
    // Signal too weak, increase gain
    if (current_gain &lt; 5) PGA_Gain = current_gain + 1;
} else if (ADC_12bit &gt; 3584) {
    // Signal too strong, decrease gain
    if (current_gain &gt; 0) PGA_Gain = current_gain - 1;
} else {
    // Signal in optimal range, maintain current gain
    PGA_Gain = current_gain;
}

// Result: Adaptive gain maintains ADC input in optimal range
// Effective dynamic range: 1000:1 light intensity
                </div>
            </div>

            <h3>Example 3: Differential Current Sensing for Motor Control</h3>
            <div class="example">
                <strong>Application:</strong> Motor current measurement via shunt resistor
                <div class="code-block">
// Configuration:
// - PGA1Gain = "Gain 32 (2⁵)" (maximum amplification)
// - PGA1P_pin = "PGA1P1 / RA0 / Pin[2]" (shunt high side)
// - PGA1N_pin = "PGA1N1 / RA1 / Pin[3]" (shunt low side)
// - PGA1Output = "off" (internal to ADC)
// - PGA1Gain_BlockInput = "off"

// Hardware:
// - Motor → 0.01Ω shunt → Motor_GND
// - Shunt voltage: 10A × 0.01Ω = 100mV (differential)
// - PGA1P (high side) and PGA1N (low side) measure shunt voltage

// Register configuration:
PGA1CONbits.PGAEN = 1;     // Enable PGA1
PGA1CONbits.PGOEN = 0;     // Internal output
PGA1CONbits.SELPI = 1;     // PGA1P1 (shunt high)
PGA1CONbits.SELNI = 1;     // PGA1N1 (shunt low)
PGA1CONbits.GAIN = 5;      // 2⁵ = 32× gain

// Current measurement:
// Motor current: 10A → Shunt: 100mV → PGA: 3.2V → ADC
// ADC reading × (3.3V/4096) / 32 / 0.01Ω = Motor current

// Synchronization with PWM:
// - Trigger ADC from PWM event
// - Sample during PWM off-time for clean measurement
// - Provides real-time current feedback for FOC algorithm
                </div>
            </div>

            <h3>Example 4: Cascaded PGA for Ultra-High Gain</h3>
            <div class="example">
                <strong>Application:</strong> Piezoelectric sensor with μV output
                <div class="code-block">
// Configuration:
// - PGA1: Gain 32× (first stage)
// - PGA2: Gain 32× (second stage)
// - Total gain: 32 × 32 = 1024×

// PGA1 Configuration:
// - PGA1Gain = "Gain 32 (2⁵)"
// - PGA1P_pin = "PGA1P1 / RA0" (piezo sensor)
// - PGA1N_pin = "Ground (Single-Ended mode)"
// - PGA1Output = "on" → DACOUT1 (external connection to PGA2)

// PGA2 Configuration:
// - PGA2Gain = "Gain 32 (2⁵)"
// - PGA2P_pin = "PGA2P1 / RB0" (connected to DACOUT1)
// - PGA2N_pin = "Ground (Single-Ended mode)"
// - PGA2Output = "off" (internal to ADC)

// External connection:
// DACOUT1 (PGA1 output) → PGA2P1 (wire or PCB trace)

// Signal chain:
// Piezo: 3mV → PGA1 (32×) → 96mV → PGA2 (32×) → 3.072V → ADC
// Total gain: 1024× (60dB)

// Note: Watch for noise pickup on DACOUT1 → PGA2P1 connection
// Use short trace, ground plane, and decoupling capacitor
                </div>
            </div>
        </div>

        <div class="content-card">
            <h2>Calibration and Offset Correction</h2>

            <h3>PGA Offset Error Sources</h3>
            <ul>
                <li><strong>Input Offset Voltage:</strong> Inherent op-amp offset (typically ±1-5 mV)</li>
                <li><strong>Gain Error:</strong> Deviation from ideal gain (typically ±1-3%)</li>
                <li><strong>Temperature Drift:</strong> Offset changes over temperature (μV/°C)</li>
                <li><strong>Reference Errors:</strong> Ground reference or supply voltage variations</li>
            </ul>

            <h3>Software Calibration Procedure</h3>
            <div class="code-block">
// Two-point calibration for PGA accuracy

// Step 1: Zero-point calibration (offset correction)
// Apply 0V to both PGA inputs (short P and N to ground)
ADC_offset = ADC_Read();  // Measure output with 0V input
// Store offset for subtraction during measurement

// Step 2: Full-scale calibration (gain correction)
// Apply known reference voltage (e.g., 1.000V from precision source)
ADC_fullscale = ADC_Read();  // Measure output with known input
gain_error = (ADC_fullscale - ADC_offset) / Expected_Value;
// Store gain error for multiplication correction

// Step 3: Apply calibration to measurements
ADC_raw = ADC_Read();
ADC_calibrated = (ADC_raw - ADC_offset) / gain_error;
Voltage_actual = ADC_calibrated × (Vref / 4096) / PGA_Gain;
            </div>

            <h3>Automatic Gain Ranging with Calibration</h3>
            <div class="code-block">
// Maintain separate calibration for each gain setting
typedef struct {
    int16_t offset;      // Zero-point offset
    float gain_error;    // Gain correction factor
} PGA_Calibration_t;

PGA_Calibration_t cal[6];  // Calibration for each gain (1×, 2×, 4×, 8×, 16×, 32×)

// Calibration at startup (run once for each gain)
for (gain_idx = 0; gain_idx &lt; 6; gain_idx++) {
    PGA_SetGain(gain_idx);  // Update PGA gain
    delay_us(100);          // Settling time
    // Apply known reference voltages and calibrate
    cal[gain_idx].offset = MeasureOffset();
    cal[gain_idx].gain_error = MeasureGainError();
}

// Runtime measurement with auto-ranging
current_gain_idx = SelectOptimalGain(signal_estimate);
PGA_SetGain(current_gain_idx);
ADC_raw = ADC_Read();
ADC_cal = (ADC_raw - cal[current_gain_idx].offset) / cal[current_gain_idx].gain_error;
            </div>

            <div class="warning">
                <strong>Calibration Considerations:</strong>
                <ul>
                    <li>Perform calibration at operating temperature for best accuracy</li>
                    <li>Store calibration data in EEPROM or Flash for persistence across power cycles</li>
                    <li>Re-calibrate periodically if drift is significant (e.g., every hour or temperature change)</li>
                    <li>Use high-precision reference voltage source for gain calibration (better than 0.1% accuracy)</li>
                </ul>
            </div>
        </div>

        <div class="content-card">
            <h2>Design Guidelines</h2>

            <h3>Input Signal Conditioning</h3>
            <ul>
                <li><strong>Input Range:</strong> Ensure input signal stays within 0 to VDD range (typically 0-3.3V)</li>
                <li><strong>Over-voltage Protection:</strong> Add clamping diodes for signals that may exceed VDD</li>
                <li><strong>Input Filtering:</strong> Use RC filter (e.g., 1kΩ + 100nF) to reduce high-frequency noise</li>
                <li><strong>ESD Protection:</strong> Include series resistor (1-10kΩ) for ESD-sensitive inputs</li>
            </ul>

            <h3>Gain Selection Strategy</h3>
            <div class="info">
                <strong>Gain Selection Guidelines:</strong>
                <ul>
                    <li><strong>Fixed Gain:</strong> Use when signal amplitude is well-known and constant</li>
                    <li><strong>Dynamic Gain:</strong> Use for signals with wide dynamic range (&gt;100:1)</li>
                    <li><strong>Optimal Range:</strong> Target ADC input of 0.5-2.5V for best SNR and linearity</li>
                    <li><strong>Headroom:</strong> Leave 10-20% margin to avoid saturation on signal peaks</li>
                    <li><strong>Noise Floor:</strong> Higher gain amplifies noise; balance gain vs. noise requirements</li>
                </ul>
            </div>

            <h3>Output Routing Considerations</h3>
            <table class="parameter-table">
                <tr>
                    <th>Output Mode</th>
                    <th>Advantages</th>
                    <th>Disadvantages</th>
                    <th>Use Cases</th>
                </tr>
                <tr>
                    <td><strong>Internal Only</strong><br>(PGOEN = 0)</td>
                    <td>
                        • Saves pins<br>
                        • Lower noise<br>
                        • Direct ADC connection
                    </td>
                    <td>
                        • No external access<br>
                        • Cannot drive external loads
                    </td>
                    <td>
                        Single-chip applications,<br>
                        on-chip ADC only
                    </td>
                </tr>
                <tr>
                    <td><strong>DACOUT Pin</strong><br>(PGOEN = 1)</td>
                    <td>
                        • External monitoring<br>
                        • Drive external ADC<br>
                        • Test point access
                    </td>
                    <td>
                        • Uses additional pin<br>
                        • Potential noise pickup<br>
                        • Capacitive loading
                    </td>
                    <td>
                        Multi-chip systems,<br>
                        external ADC,<br>
                        debug/test
                    </td>
                </tr>
            </table>

            <h3>PCB Layout Best Practices</h3>
            <ul>
                <li><strong>Separate Grounds:</strong> Use analog ground plane, connect to digital ground at single point</li>
                <li><strong>Short Traces:</strong> Keep PGA input traces as short as possible (&lt;1 inch preferred)</li>
                <li><strong>Guard Rings:</strong> Surround sensitive input traces with grounded guard traces</li>
                <li><strong>Decoupling:</strong> Place 100nF capacitor close to VDD pin (&lt;5mm)</li>
                <li><strong>Shielding:</strong> Route PGA signals away from switching noise sources (PWM, clocks)</li>
            </ul>
        </div>

        <div class="content-card">
            <h2>Troubleshooting</h2>

            <table class="parameter-table">
                <tr>
                    <th>Issue</th>
                    <th>Possible Causes</th>
                    <th>Solution</th>
                </tr>
                <tr>
                    <td>No output signal</td>
                    <td>
                        • PGAEN not set<br>
                        • Incorrect pin selection<br>
                        • Input shorted to ground
                    </td>
                    <td>
                        Verify PGA is enabled in block parameters. Check SELPI/SELNI match
                        actual hardware connections. Measure input pins with oscilloscope.
                    </td>
                </tr>
                <tr>
                    <td>Output saturated (clipped)</td>
                    <td>
                        • Gain too high<br>
                        • Input signal too large<br>
                        • Offset error
                    </td>
                    <td>
                        Reduce gain setting or input signal amplitude. Verify input is within
                        0-VDD range. Check offset calibration. Ensure VDD provides adequate headroom.
                    </td>
                </tr>
                <tr>
                    <td>Incorrect gain</td>
                    <td>
                        • Wrong GAIN bits<br>
                        • Dynamic gain input error<br>
                        • Calibration drift
                    </td>
                    <td>
                        Verify block parameter matches desired gain. Check dynamic gain input
                        value (0-5 for 1×-32×). Re-run calibration procedure.
                    </td>
                </tr>
                <tr>
                    <td>Excessive noise</td>
                    <td>
                        • High gain amplifying noise<br>
                        • Poor PCB layout<br>
                        • Missing input filter
                    </td>
                    <td>
                        Add RC input filter (1kΩ + 100nF). Improve ground plane and shielding.
                        Reduce gain if SNR is adequate. Check for digital noise coupling.
                    </td>
                </tr>
                <tr>
                    <td>DC offset error</td>
                    <td>
                        • Input offset voltage<br>
                        • No calibration<br>
                        • Temperature drift
                    </td>
                    <td>
                        Run zero-point calibration procedure. Store offset correction in software.
                        Re-calibrate periodically or after temperature changes.
                    </td>
                </tr>
                <tr>
                    <td>DACOUT1/2 conflict</td>
                    <td>
                        • DBCC bridge enabled<br>
                        • Both outputs trying to drive pin
                    </td>
                    <td>
                        Check Fuse_FDEVOPT_DBCC status. If bridge enabled, only use one PGA
                        output to avoid conflict. Configure in master block if change needed.
                    </td>
                </tr>
            </table>
        </div>

        <div class="content-card">
            <h2>Related Blocks</h2>
            <ul>
                <li><a href="op_amp.html">MCHP_OP_AMP</a> - Operational amplifier for custom gain circuits</li>
                <li><a href="MCHP_HighSpeed_AnalogComparator.html">MCHP_HighSpeed_AnalogComparator</a> - Threshold detection after amplification</li>
                <li><a href="../adc/adc_hs_sar_dspic33.html">MCHP_ADC_HS_SAR_dsPIC33</a> - High-speed ADC for digitizing PGA outputs</li>
                <li><a href="../adc/adc_coreindependent_pic32c.html">MCHP_ADC_CoreIndependent_PIC32C</a> - SAM family ADC integration</li>
            </ul>
        </div>

        <a href="analog.html" class="back-link">← Back to Analog Blocks</a>
    </div>
    </div>
</body>
</html>
