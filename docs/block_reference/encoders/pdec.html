<!DOCTYPE html>
<html>
<head>
    <title>MCHP_PDEC - Position Decoder for SAM Devices</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../../assets/css/navigation.css">
    <script src="../../assets/js/navigation.js"></script>
</head>
<body>
    <!-- Mobile Navigation Toggle -->
    <button class="nav-toggle" aria-label="Toggle navigation">☰</button>

    <!-- Left Navigation Panel -->
    <nav class="doc-nav-container">
        <div class="doc-nav-header">
            <a href="../../index.html">MCHP Blockset Docs</a>
        </div>
        <ul class="doc-nav-menu">
            <li class="nav-item">
                <a href="../../index.html" class="nav-link">Home</a>
            </li>

            <!-- Getting Started Section -->
            <li class="nav-item">
                <div class="nav-category">Getting Started <span class="nav-category-icon">▼</span></div>
                <ul class="nav-list">
                    <li><a href="../../getting_started/overview.html" class="nav-link">Overview</a></li>
                    <li><a href="../../getting_started/installation.html" class="nav-link">Installation</a></li>
                    <li><a href="../../getting_started/quick_start.html" class="nav-link">Quick Start</a></li>
                    <li><a href="../../getting_started/board_templates.html" class="nav-link">Board Templates</a></li>
                    <li><a href="../../getting_started/supported_devices.html" class="nav-link">Supported Devices</a></li>
                </ul>
            </li>

            <!-- User Guide Section -->
            <li class="nav-item">
                <div class="nav-category">User Guide <span class="nav-category-icon">▼</span></div>
                <ul class="nav-list">
                    <li><a href="../../user_guide/index.html" class="nav-link">User Guide Overview</a></li>
                    <li><a href="../../user_guide/code_generation.html" class="nav-link">Code Generation</a></li>
                    <li><a href="../../user_guide/external_mode.html" class="nav-link">External Mode</a></li>
                </ul>
            </li>

            <!-- Block Reference Section -->
            <li class="nav-item">
                <div class="nav-category">Block Reference <span class="nav-category-icon">▼</span></div>
                <ul class="nav-list">
                    <li><a href="../../block_reference/index.html" class="nav-link">Block Reference Overview</a></li>
                </ul>
            </li>

            <!-- Examples Section -->
            <li class="nav-item">
                <div class="nav-category">Examples <span class="nav-category-icon">▼</span></div>
                <ul class="nav-list">
                    <li><a href="../../examples/field_weakening.html" class="nav-link">Field Weakening</a></li>
                </ul>
            </li>

            <!-- Release Notes -->
            <li class="nav-item">
                <a href="../../release_notes.html" class="nav-link">Release Notes</a>
            </li>
        </ul>
    </nav>

    <div class="doc-content-wrapper">
    <div class="breadcrumb">
        <a href="../index.html">MCHP Blockset</a> &gt;
        <a href="encoders.html">Encoder & Counter Blocks</a> &gt;
        <strong>PDEC</strong>
    </div>

    <div class="header">
        <h1>MCHP_PDEC</h1>
        <p>Position Decoder - Hall Sensors and Stepper Motor Interface</p>
    </div>

    <div class="content-section">
        
    <!-- Block Icon -->
    <div class="block-image">
        <img src="../assets/images/blocks/digital/PDEC.svg"
             alt="PDEC Block Icon"
             onerror="this.onerror=null; this.src='../assets/images/blocks/digital/PDEC.png';">
        <div class="block-image-caption">
            PDEC Block Icon
        </div>
    </div>
<h2>Overview</h2>
        <p>The MCHP_PDEC block provides an interface to the Position Decoder (PDEC) peripheral on SAM E5x and E7x microcontrollers. Unlike traditional quadrature encoders, PDEC is optimized for Hall effect sensors (3-phase BLDC motors) and stepper motor position tracking, with specialized features for these applications.</p>

        <div class="note-box">
            <strong>Key Features:</strong>
            <ul>
                <li>3-input position decoder (Hall sensors: A, B, C)</li>
                <li>Quadrature encoder mode (X2/X4)</li>
                <li>Counter with direction input mode</li>
                <li>Configurable position counter and revolution counter</li>
                <li>Auto-correction for phase errors</li>
                <li>Programmable digital filtering</li>
                <li>Index pulse support</li>
                <li>Angular position calculation (9-bit + configurable resolution)</li>
            </ul>
        </div>

        <h3>Device Support</h3>
        <div class="device-table">
            <table class="parameter-table">
                <tr>
                    <th>Family</th>
                    <th>PDEC Module</th>
                    <th>Features</th>
                </tr>
                <tr>
                    <td>SAM E54/E53/E51</td>
                    <td>1</td>
                    <td>Hall sensor, quadrature, stepper position</td>
                </tr>
                <tr>
                    <td>SAM E70/S70/V71</td>
                    <td>1</td>
                    <td>Hall sensor, quadrature, stepper position</td>
                </tr>
            </table>
        </div>
    </div>

    <div class="content-section">
        <h2>Block Parameters</h2>

        <h3>Operating Mode</h3>
        <table class="parameter-table">
            <tr>
                <th>Parameter</th>
                <th>Options</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>Mode</td>
                <td>
                    • Quadrature Encoder<br>
                    • Counter with direction<br>
                    • Counter
                </td>
                <td>Position decoding mode</td>
            </tr>
        </table>

        <h3>Position Configuration</h3>
        <table class="parameter-table">
            <tr>
                <th>Parameter</th>
                <th>Options</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>Counter Output</td>
                <td>on/off</td>
                <td>Enable position counter output</td>
            </tr>
            <tr>
                <td>Counter Datatype</td>
                <td>unsigned/signed</td>
                <td>Position counter sign</td>
            </tr>
            <tr>
                <td>Revolution Output</td>
                <td>on/off</td>
                <td>Enable revolution counter</td>
            </tr>
            <tr>
                <td>Revolution Datatype</td>
                <td>unsigned/signed</td>
                <td>Revolution counter sign</td>
            </tr>
            <tr>
                <td>Counter Revolution Length</td>
                <td>
                    • Counter is 16-bit (9+7 bit resolution)<br>
                    • Counter is 17-bit (9+8 bit resolution)<br>
                    ...<br>
                    • Counter is 23-bit (9+14 bit resolution)
                </td>
                <td>Position/revolution bit allocation (9-bit angular + N-bit revolution)</td>
            </tr>
        </table>

        <h3>Index and Reset</h3>
        <table class="parameter-table">
            <tr>
                <th>Parameter</th>
                <th>Options</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>Index</td>
                <td>
                    • Not used<br>
                    • Reset counter<br>
                    • Reset counter once only
                </td>
                <td>Index pulse behavior</td>
            </tr>
            <tr>
                <td>Max Counter Reset</td>
                <td>Integer value</td>
                <td>Modulo limit for position counter</td>
            </tr>
            <tr>
                <td>Max Position Input</td>
                <td>on/off</td>
                <td>Enable dynamic modulo limit via block input</td>
            </tr>
            <tr>
                <td>Reset Input</td>
                <td>on/off</td>
                <td>Enable external reset input</td>
            </tr>
        </table>

        <h3>Signal Configuration</h3>
        <table class="parameter-table">
            <tr>
                <th>Pin</th>
                <th>Function (Quadrature)</th>
                <th>Function (Hall Sensor)</th>
            </tr>
            <tr>
                <td>QDI0</td>
                <td>Phase A</td>
                <td>Hall A</td>
            </tr>
            <tr>
                <td>QDI1</td>
                <td>Phase B</td>
                <td>Hall B</td>
            </tr>
            <tr>
                <td>QDI2</td>
                <td>Index</td>
                <td>Hall C</td>
            </tr>
        </table>

        <table class="parameter-table">
            <tr>
                <th>Parameter</th>
                <th>Options</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>Invert QDI0/1/2</td>
                <td>on/off</td>
                <td>Invert input polarity</td>
            </tr>
            <tr>
                <td>Swap Pin Phase A & B</td>
                <td>on/off</td>
                <td>Reverse direction (quadrature mode)</td>
            </tr>
            <tr>
                <td>Auto Correction</td>
                <td>on/off</td>
                <td>Automatic phase error correction</td>
            </tr>
            <tr>
                <td>Digital Filter</td>
                <td>disabled or time period</td>
                <td>Input signal filtering</td>
            </tr>
        </table>
    </div>

    <div class="content-section">
        <h2>Hall Sensor Operation</h2>

        <h3>3-Phase Hall Sensor Interface</h3>
        <p>PDEC decodes 3-wire Hall sensor signals for BLDC motor position:</p>

        <div class="diagram">
Hall Sensor States (6-step commutation):
  State  | Hall A | Hall B | Hall C | Sector
  -------|--------|--------|--------|--------
    1    |   0    |   0    |   1    |  0-60°
    2    |   0    |   1    |   1    |  60-120°
    3    |   0    |   1    |   0    |  120-180°
    4    |   1    |   1    |   0    |  180-240°
    5    |   1    |   0    |   0    |  240-300°
    6    |   1    |   0    |   1    |  300-360°

Valid transitions: 1→2→3→4→5→6→1 (CW)
                   1→6→5→4→3→2→1 (CCW)
        </div>

        <h3>Angular Position Calculation</h3>
        <div class="code-block">
<span class="comment">// PDEC provides 9-bit angular resolution within each sector</span>
Angular_bits = 9;  <span class="comment">// Fixed 9-bit per sector (0-511)</span>
Sector = 0 to 5;   <span class="comment">// From Hall state</span>

<span class="comment">// Total position = (Sector * 512) + Angular_position</span>
Counts_per_rev = 6 * 512 = 3072;

<span class="comment">// Convert to electrical angle</span>
Electrical_angle_deg = (Position_count / 3072) * 360;

<span class="comment">// For motor with 4 pole pairs:</span>
Mechanical_angle_deg = Electrical_angle_deg / 4;
        </div>

        <h3>PDEC Registers (SAM E5x)</h3>
        <div class="code-block">
<span class="comment">// Control Register</span>
PDEC->CTRLA.bit.MODE = 0;        <span class="comment">// QDEC mode</span>
PDEC->CTRLA.bit.CONF = 1;        <span class="comment">// X4 quadrature (secure)</span>
PDEC->CTRLA.bit.PINEN = 0b111;   <span class="comment">// Enable all 3 inputs</span>
PDEC->CTRLA.bit.PINVEN = 0b000;  <span class="comment">// Invert mask</span>
PDEC->CTRLA.bit.SWAP = 0;        <span class="comment">// No pin swap</span>
PDEC->CTRLA.bit.PEREN = 1;       <span class="comment">// Enable period/modulo</span>

<span class="comment">// Position Counter (16-bit)</span>
count = PDEC->COUNT.reg;         <span class="comment">// Current count (9-bit angular + N-bit revolution)</span>

<span class="comment">// Angular position (9-bit within sector)</span>
angular = count & 0x1FF;         <span class="comment">// Lower 9 bits</span>

<span class="comment">// Revolution counter (upper bits)</span>
revolution = count >> 9;         <span class="comment">// Upper N bits</span>

<span class="comment">// Period register (modulo limit)</span>
PDEC->CC[0].reg = max_position;  <span class="comment">// Position wraps at this value</span>

<span class="comment">// Digital Filter</span>
PDEC->FILTER.bit.FILTER = filter_value;  <span class="comment">// 0=disabled, 1-255=filter clocks</span>
        </div>
    </div>

    <div class="content-section">
        <h2>Examples</h2>

        <h3>Example 1: BLDC Motor with Hall Sensors</h3>
        <div class="example-box">
            <h4>Application: 3-Phase BLDC Motor Position Feedback</h4>
            <p><strong>Hardware:</strong> BLDC motor with 3 Hall sensors, 4 pole pairs</p>
            <p><strong>Configuration:</strong></p>
            <ul>
                <li>Mode: Quadrature Encoder</li>
                <li>Counter Output: on (unsigned)</li>
                <li>Counter Length: 16-bit (9+7, allows 128 revolutions)</li>
                <li>Index: Not used</li>
            </ul>

            <div class="code-block">
<span class="comment">// Position calculation</span>
Position_count = PDEC_Output;
Angular_9bit = Position_count & 0x1FF;   <span class="comment">// 0-511 within sector</span>
Revolution = Position_count >> 9;        <span class="comment">// Revolution count</span>

<span class="comment">// Hall sector (0-5) from upper 3 bits of angular position</span>
Sector = Angular_9bit >> 6;              <span class="comment">// Approximate sector</span>

<span class="comment">// Electrical angle (0-360°)</span>
Elec_angle_deg = (Position_count % 3072) / 3072 * 360;

<span class="comment">// Mechanical angle (4 pole pairs)</span>
Mech_angle_deg = Elec_angle_deg / 4;

<span class="comment">// Commutation sector for 6-step drive</span>
Commutation_sector = floor(Elec_angle_deg / 60);  <span class="comment">// 0-5</span>
            </div>
        </div>

        <h3>Example 2: Stepper Motor Position Tracking</h3>
        <div class="example-box">
            <h4>Application: Open-Loop Stepper with Position Feedback</h4>
            <p><strong>Configuration:</strong></p>
            <ul>
                <li>Mode: Counter with direction</li>
                <li>QDI0: Step pulse input</li>
                <li>QDI1: Direction input (HIGH=CW, LOW=CCW)</li>
                <li>Counter Output: 32-bit signed</li>
            </ul>

            <div class="code-block">
<span class="comment">// For 200 steps/rev stepper (1.8° per step)</span>
Steps_per_rev = 200;
Position_steps = PDEC_Counter;

<span class="comment">// Convert to angle</span>
Angle_deg = (Position_steps % Steps_per_rev) * 1.8;

<span class="comment">// Full revolutions</span>
Revolutions = floor(Position_steps / Steps_per_rev);

<span class="comment">// Microstep mode: 1/16 microstepping = 3200 steps/rev</span>
Microsteps_per_rev = 200 * 16;
Microstep_angle_deg = (Position_steps % Microsteps_per_rev) / Microsteps_per_rev * 360;
            </div>
        </div>

        <h3>Example 3: Index-Based Homing</h3>
        <div class="example-box">
            <h4>Application: Absolute Position Reference Using Index Pulse</h4>
            <p><strong>Configuration:</strong></p>
            <ul>
                <li>Mode: Quadrature Encoder</li>
                <li>Index: Reset counter once only</li>
                <li>Auto Correction: on (for Hall sensor noise immunity)</li>
            </ul>

            <div class="code-block">
<span class="comment">// Homing procedure:</span>
<span class="comment">// 1. Power on: position undefined</span>
<span class="comment">// 2. Rotate motor until index pulse</span>
<span class="comment">// 3. Counter resets to 0 (once only)</span>
<span class="comment">// 4. Position now referenced to index</span>

<span class="keyword">if</span> (first_index_detected) {
    <span class="comment">// Position is now absolute</span>
    Absolute_position = PDEC_Counter;
    Homed = <span class="keyword">true</span>;
}
            </div>
        </div>

        <h3>Example 4: Dynamic Modulo Limit</h3>
        <div class="example-box">
            <h4>Application: Variable Position Range</h4>
            <p><strong>Configuration:</strong></p>
            <ul>
                <li>Max Position Input: on</li>
                <li>Counter wraps at value from MAXPOS input port</li>
            </ul>

            <div class="code-block">
<span class="comment">// Set position range dynamically based on application</span>
<span class="comment">// Example: Adjust range based on motor load or operating mode</span>

<span class="keyword">if</span> (high_speed_mode) {
    MAXPOS_input = 1000;  <span class="comment">// Limited range at high speed</span>
} <span class="keyword">else</span> {
    MAXPOS_input = 5000;  <span class="comment">// Full range at low speed</span>
}

<span class="comment">// Position wraps at MAXPOS_input</span>
<span class="comment">// Counter: 0 → MAXPOS_input-1 → 0 → ...</span>
            </div>
        </div>
    </div>

    <div class="content-section">
        <h2>Troubleshooting</h2>

        <div class="warning-box">
            <h4>Issue: Incorrect Hall Sequence Detection</h4>
            <p><strong>Causes:</strong></p>
            <ul>
                <li>Hall sensors wired incorrectly (wrong A/B/C assignment)</li>
                <li>Hall sensor polarity inverted</li>
                <li>One Hall sensor not working (stuck at 0 or 1)</li>
            </ul>
            <p><strong>Solutions:</strong></p>
            <ul>
                <li>Use "Invert QDI" options to correct polarity</li>
                <li>Enable Auto Correction for minor glitches</li>
                <li>Verify Hall wiring with multimeter or oscilloscope</li>
                <li>Check Hall sensor power supply (typically 5V or 12V)</li>
            </ul>
        </div>

        <div class="warning-box">
            <h4>Issue: Position Jumps or Glitches</h4>
            <p><strong>Solution:</strong> Enable digital filter to suppress noise. Start with 1 µs filter period and increase if needed.</p>
        </div>

        <div class="warning-box">
            <h4>Issue: Wrong Direction</h4>
            <p><strong>Solution:</strong> Enable "Swap Pin Phase A & B" to reverse counting direction.</p>
        </div>
    </div>

    <div class="content-section">
        <h2>Related Blocks</h2>
        <ul>
            <li><a href="qei.html"><strong>MCHP_QEI</strong></a> - Quadrature Encoder Interface for dsPIC/PIC32</li>
            <li><a href="qdec_samx.html"><strong>MCHP_QDEC_SAMx</strong></a> - Quadrature Decoder using TC modules</li>
            <li><strong>MCHP_PWM_SAMx</strong> - PWM for BLDC motor drive (works with PDEC Hall inputs)</li>
        </ul>
    </div>

    <div class="content-section">
        <h2>References</h2>
        <ul>
            <li><strong><a href="https://www.microchip.com/DS60001507">SAM E54 Family Datasheet (DS60001507)</a></strong> - PDEC Position Decoder section</li>
            <li><strong><a href="https://www.microchip.com/DS60001527">SAM E70 Family Datasheet (DS60001527)</a></strong> - PDEC peripheral</li>
            <li><strong>Atmel Application Note:</strong> BLDC Motor Control with Hall Sensors (search <a href="https://www.microchip.com/en-us/search">Microchip Documentation Portal</a>)</li>
            <li><strong>PDEC Angular Position Calculation:</strong> Family reference manual chapter on position decoding (see datasheets above)</li>
        </ul>
    </div>

    <div class="content-section" style="background-color: #f8f9fa; border-top: 3px solid #667eea; margin-top: 40px;">
        <p><strong>See Also:</strong> <a href="encoders.html">Encoder & Counter Blocks Overview</a> | <a href="../index.html">MCHP Blockset Documentation</a></p>
        <p style="color: #666; font-size: 0.9em;">Last Updated: 2024 | MCHP Blockset for MATLAB/Simulink</p>
    </div>
    </div>
</body>
</html>
