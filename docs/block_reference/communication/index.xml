<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Communication Blocks on MPLAB Blockset for MATLAB/Simulink</title><link>/block_reference/communication/index.html</link><description>Recent content in Communication Blocks on MPLAB Blockset for MATLAB/Simulink</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 16 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="/block_reference/communication/index.xml" rel="self" type="application/rss+xml"/><item><title>CAN Config</title><link>/block_reference/communication/can/can_config.html</link><pubDate>Thu, 16 Oct 2025 00:00:00 +0000</pubDate><guid>/block_reference/communication/can/can_config.html</guid><description>&lt;div class="block-icon-container"&gt;
 &lt;picture class="block-icon-image"&gt;
 &lt;source srcset="../../assets/images/blocks/bus_can/CAN_Config.svg" type="image/svg+xml"&gt;
 &lt;img src="../../assets/images/blocks/bus_can/CAN_Config.png" alt="CAN Config Block Icon"&gt;
 &lt;/picture&gt;
 &lt;div class="block-icon-description"&gt;
 The &lt;strong&gt;CAN Config&lt;/strong&gt; block configures the Controller Area Network (CAN) peripheral for communication on CAN bus networks. This block sets up essential parameters including bit timing (baud rate), message buffer allocation, filtering configuration, and interrupt priorities. The CAN Config block must be present in your model before using CAN Tx or CAN Rx blocks. CAN is a robust, multi-master serial bus system designed for networking intelligent devices. It is widely used in automotive, industrial automation, and embedded systems for reliable communication in electrically noisy environments. The protocol features automatic message prioritization, error detection, and fault confinement mechanisms.
 &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;strong&gt;CAN Config&lt;/strong&gt; block configures the Controller Area Network (CAN) peripheral for communication on CAN bus networks. This block sets up essential parameters including bit timing (baud rate), message buffer allocation, filtering configuration, and interrupt priorities. The CAN Config block must be present in your model before using CAN Tx or CAN Rx blocks.&lt;/p&gt;</description></item><item><title>CAN Rx</title><link>/block_reference/communication/can/can_rx.html</link><pubDate>Thu, 16 Oct 2025 00:00:00 +0000</pubDate><guid>/block_reference/communication/can/can_rx.html</guid><description>&lt;div class="block-icon-container"&gt;
 &lt;picture class="block-icon-image"&gt;
 &lt;source srcset="../../assets/images/blocks/bus_can/CAN_Rx.svg" type="image/svg+xml"&gt;
 &lt;img src="../../assets/images/blocks/bus_can/CAN_Rx.png" alt="CAN Rx Block Icon"&gt;
 &lt;/picture&gt;
 &lt;div class="block-icon-description"&gt;
 The &lt;strong&gt;CAN Rx&lt;/strong&gt; block receives CAN messages from the CAN bus network and outputs the message ID, data length, and payload data. The block supports flexible message filtering with standard (11-bit) and extended (29-bit) identifiers, multiple filter types (exact match, range, mask), and configurable storage in dedicated buffers or FIFOs. This block requires a &lt;strong&gt;CAN Config&lt;/strong&gt; block in the same model to configure the CAN peripheral. Multiple CAN Rx blocks can be used to receive different messages on the same CAN module, each with its own filter configuration.
 &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;strong&gt;CAN Rx&lt;/strong&gt; block receives CAN messages from the CAN bus network and outputs the message ID, data length, and payload data. The block supports flexible message filtering with standard (11-bit) and extended (29-bit) identifiers, multiple filter types (exact match, range, mask), and configurable storage in dedicated buffers or FIFOs.&lt;/p&gt;</description></item><item><title>CAN Tx</title><link>/block_reference/communication/can/can_tx.html</link><pubDate>Thu, 16 Oct 2025 00:00:00 +0000</pubDate><guid>/block_reference/communication/can/can_tx.html</guid><description>&lt;div class="block-icon-container"&gt;
 &lt;picture class="block-icon-image"&gt;
 &lt;source srcset="../../assets/images/blocks/bus_can/CAN_Tx.svg" type="image/svg+xml"&gt;
 &lt;img src="../../assets/images/blocks/bus_can/CAN_Tx.png" alt="CAN Tx Block Icon"&gt;
 &lt;/picture&gt;
 &lt;div class="block-icon-description"&gt;
 The &lt;strong&gt;CAN Tx&lt;/strong&gt; block transmits CAN messages on the CAN bus network. It accepts message data and length as inputs, and sends the message with the configured ID and format. The block supports both standard (11-bit) and extended (29-bit) identifiers, remote transmission requests (RTR), and both dedicated buffer and FIFO transmission modes. This block requires a &lt;strong&gt;CAN Config&lt;/strong&gt; block in the same model to configure the CAN peripheral. Multiple CAN Tx blocks can be used to send different messages on the same CAN module.
 &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;strong&gt;CAN Tx&lt;/strong&gt; block transmits CAN messages on the CAN bus network. It accepts message data and length as inputs, and sends the message with the configured ID and format. The block supports both standard (11-bit) and extended (29-bit) identifiers, remote transmission requests (RTR), and both dedicated buffer and FIFO transmission modes.&lt;/p&gt;</description></item><item><title>UART Break/Autobaud</title><link>/block_reference/communication/uart/uart_break_and_autobaud.html</link><pubDate>Thu, 16 Oct 2025 00:00:00 +0000</pubDate><guid>/block_reference/communication/uart/uart_break_and_autobaud.html</guid><description>&lt;div class="block-icon-container"&gt;
 &lt;picture class="block-icon-image"&gt;
 &lt;source srcset="../../assets/images/blocks/bus_uart/UART_Config.svg" type="image/svg+xml"&gt;
 &lt;img src="../../assets/images/blocks/bus_uart/UART_Config.png" alt="UART Break and Autobaud Block Icon"&gt;
 &lt;/picture&gt;
 &lt;div class="block-icon-description"&gt;
 Microchip UART modules support advanced communication features including Break character transmission/detection and Auto-Baud rate detection for robust communication in systems where baud rates are unknown or need synchronization.
 &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;Microchip UART modules support advanced communication features including &lt;strong&gt;Break character transmission/detection&lt;/strong&gt; and &lt;strong&gt;Auto-Baud rate detection&lt;/strong&gt;. These features enable robust communication in systems where baud rates are unknown or need synchronization, and provide special signaling capabilities for protocol implementations.&lt;/p&gt;</description></item><item><title>UART Config Block</title><link>/block_reference/communication/uart/uart_config.html</link><pubDate>Thu, 16 Oct 2025 00:00:00 +0000</pubDate><guid>/block_reference/communication/uart/uart_config.html</guid><description>&lt;div class="block-icon-container"&gt;
 &lt;picture class="block-icon-image"&gt;
 &lt;source srcset="../../assets/images/blocks/bus_uart/UART_Config.svg" type="image/svg+xml"&gt;
 &lt;img src="../../assets/images/blocks/bus_uart/UART_Config.png" alt="UART Config Block Icon"&gt;
 &lt;/picture&gt;
 &lt;div class="block-icon-description"&gt;
 UART_Config Block The &lt;strong&gt;UART Config&lt;/strong&gt; block configures a UART (Universal Asynchronous Receiver/Transmitter) module for serial communication. This block sets up baud rate, pin assignments, operating modes, and implementation methods for both transmit and receive operations.
 &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="supported-device-families"&gt;Supported Device Families&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Family&lt;/th&gt;
 &lt;th&gt;Series&lt;/th&gt;
 &lt;th&gt;Architecture ID&lt;/th&gt;
 &lt;th&gt;Notes&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;dsPIC&lt;/td&gt;
 &lt;td&gt;30F, 24F, 33F, 33E, 33C, 33A&lt;/td&gt;
 &lt;td&gt;1, 2, 3, 4, 8&lt;/td&gt;
 &lt;td&gt;Full support including IrDA on capable devices&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;PIC32&lt;/td&gt;
 &lt;td&gt;MK, MZ, MX, PIC32A&lt;/td&gt;
 &lt;td&gt;Included in dsPIC arch&lt;/td&gt;
 &lt;td&gt;Standard UART functionality&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;SAM&lt;/td&gt;
 &lt;td&gt;E7x, E5x, D5x, C2x, D2x&lt;/td&gt;
 &lt;td&gt;5, 6, 7&lt;/td&gt;
 &lt;td&gt;USART peripheral (SAMx callback variants)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="configuration-parameters"&gt;Configuration Parameters&lt;/h2&gt;
&lt;h3 id="uart-selection"&gt;UART Selection&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;UART Module&lt;/strong&gt; - Select UART/USART number (1 to N, depending on device)&lt;/li&gt;
&lt;li&gt;Number of available UARTs detected automatically from selected chip&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="baud-rate-configuration"&gt;Baud Rate Configuration&lt;/h3&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Parameter&lt;/th&gt;
 &lt;th&gt;Options&lt;/th&gt;
 &lt;th&gt;Description&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;Baud Rate Selection&lt;/td&gt;
 &lt;td&gt;Popup list or Custom&lt;/td&gt;
 &lt;td&gt;Choose from standard rates (110 to 12M baud) or enter custom value&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Standard Rates&lt;/td&gt;
 &lt;td&gt;110, 300, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, &amp;hellip;&lt;/td&gt;
 &lt;td&gt;Up to 12000000 baud on capable devices&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Custom Baud&lt;/td&gt;
 &lt;td&gt;User-defined&lt;/td&gt;
 &lt;td&gt;Enter any baud rate value (validated against FCY)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Init Sequence Baud&lt;/td&gt;
 &lt;td&gt;Same options&lt;/td&gt;
 &lt;td&gt;Optional different baud rate for initialization sequence&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="operating-modes"&gt;Operating Modes&lt;/h3&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Mode&lt;/th&gt;
 &lt;th&gt;Description&lt;/th&gt;
 &lt;th&gt;Availability&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;Full Duplex&lt;/td&gt;
 &lt;td&gt;Default mode - independent Tx and Rx&lt;/td&gt;
 &lt;td&gt;All devices&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Half Duplex&lt;/td&gt;
 &lt;td&gt;One-wire Rx-Tx (shared pin)&lt;/td&gt;
 &lt;td&gt;All devices&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;IrDA Mode&lt;/td&gt;
 &lt;td&gt;Infrared communication (requires IrDA encoder/decoder)&lt;/td&gt;
 &lt;td&gt;Only on devices with UxMODE bit 12&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="transmit-tx-implementation"&gt;Transmit (Tx) Implementation&lt;/h3&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Mode&lt;/th&gt;
 &lt;th&gt;Description&lt;/th&gt;
 &lt;th&gt;Use Case&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;Do not implement Tx&lt;/td&gt;
 &lt;td&gt;No transmit capability&lt;/td&gt;
 &lt;td&gt;Receive-only applications&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Simplest&lt;/td&gt;
 &lt;td&gt;1, 4, or 8 byte internal buffer (device dependent)&lt;/td&gt;
 &lt;td&gt;Low data rate, minimal overhead&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Circular Buffer&lt;/td&gt;
 &lt;td&gt;Software circular buffer with interrupt&lt;/td&gt;
 &lt;td&gt;Moderate data rate, reliable&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;DMA Ping-Pong&lt;/td&gt;
 &lt;td&gt;Two DMA buffers alternating&lt;/td&gt;
 &lt;td&gt;High throughput, no data loss&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;DMA Circular Buffer&lt;/td&gt;
 &lt;td&gt;DMA with circular buffer&lt;/td&gt;
 &lt;td&gt;Continuous streaming&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;DMA Single Buffer&lt;/td&gt;
 &lt;td&gt;Single DMA buffer (possible data loss)&lt;/td&gt;
 &lt;td&gt;High speed, can tolerate data loss&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="receive-rx-implementation"&gt;Receive (Rx) Implementation&lt;/h3&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Mode&lt;/th&gt;
 &lt;th&gt;Description&lt;/th&gt;
 &lt;th&gt;Use Case&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;Do not implement Rx&lt;/td&gt;
 &lt;td&gt;No receive capability&lt;/td&gt;
 &lt;td&gt;Transmit-only applications&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Simplest&lt;/td&gt;
 &lt;td&gt;1, 4, or 8 byte internal buffer&lt;/td&gt;
 &lt;td&gt;Low data rate polling&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Circular Buffer&lt;/td&gt;
 &lt;td&gt;Software circular buffer with interrupt&lt;/td&gt;
 &lt;td&gt;Reliable reception, moderate rate&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;DMA Ping-Pong&lt;/td&gt;
 &lt;td&gt;Two DMA buffers alternating&lt;/td&gt;
 &lt;td&gt;High throughput reception&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="pin-configuration"&gt;Pin Configuration&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RX Pin&lt;/strong&gt; - Receive data pin (remappable on PPS-capable devices)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX Pin&lt;/strong&gt; - Transmit data pin (remappable on PPS-capable devices)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CTS Pin&lt;/strong&gt; - Clear To Send (hardware flow control, optional)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RTS Pin&lt;/strong&gt; - Request To Send (hardware flow control, optional)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DTR Pin&lt;/strong&gt; - Data Terminal Ready (dsPIC CK/33A only)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DSR Pin&lt;/strong&gt; - Data Set Ready (dsPIC CK/33A only)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="advanced-options"&gt;Advanced Options&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Idle Time Control&lt;/strong&gt; (dsPIC CK only) - Insert phantom bytes for idle time on Tx line&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Initialization Sequence&lt;/strong&gt; - Configure different settings at startup&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;External PIL Communication&lt;/strong&gt; - Enable for Processor-in-the-Loop testing&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="registers-configured"&gt;Registers Configured&lt;/h2&gt;
&lt;h3 id="dspicpic32-registers"&gt;dsPIC/PIC32 Registers&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;**``**``**``**``**``**&lt;/code&gt;&lt;/p&gt;</description></item><item><title>UART Rx Block</title><link>/block_reference/communication/uart/uart_rx.html</link><pubDate>Thu, 16 Oct 2025 00:00:00 +0000</pubDate><guid>/block_reference/communication/uart/uart_rx.html</guid><description>&lt;div class="block-icon-container"&gt;
 &lt;picture class="block-icon-image"&gt;
 &lt;source srcset="../../assets/images/blocks/bus_uart/UART_Rx.svg" type="image/svg+xml"&gt;
 &lt;img src="../../assets/images/blocks/bus_uart/UART_Rx.png" alt="UART Rx Block Icon"&gt;
 &lt;/picture&gt;
 &lt;div class="block-icon-description"&gt;
 UART_Rx Block Icon The &lt;strong&gt;UART Rx&lt;/strong&gt; block receives data from a configured UART module. This block outputs 8-bit data (uint8 type) with flexible size configuration including inherited sizing, user-defined vectors, and automatic buffer sizing based on baud rate and sample time. It works in conjunction with the &lt;strong&gt;UART Config&lt;/strong&gt; block to provide efficient serial reception.
 &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="supported-device-families"&gt;Supported Device Families&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Family&lt;/th&gt;
 &lt;th&gt;Series&lt;/th&gt;
 &lt;th&gt;Architecture ID&lt;/th&gt;
 &lt;th&gt;Implementation Files&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;dsPIC&lt;/td&gt;
 &lt;td&gt;30F, 24F, 33F, 33E, 33C, 33A&lt;/td&gt;
 &lt;td&gt;1, 2, 3, 4, 8&lt;/td&gt;
 &lt;td&gt;PIC bare, Interrupt (Circular Buffer)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;PIC32&lt;/td&gt;
 &lt;td&gt;MK, MZ, MX, PIC32A&lt;/td&gt;
 &lt;td&gt;Included in dsPIC arch&lt;/td&gt;
 &lt;td&gt;Same as dsPIC (PIC implementations)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;SAM E7x/S7x&lt;/td&gt;
 &lt;td&gt;SAME70, SAMS70, V71, PIC32CZ MC70&lt;/td&gt;
 &lt;td&gt;5&lt;/td&gt;
 &lt;td&gt;SAMx7 bare, Interrupt, DMA ping-pong&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;SAM E5x/D5x&lt;/td&gt;
 &lt;td&gt;SAME5x, SAMD5x&lt;/td&gt;
 &lt;td&gt;6&lt;/td&gt;
 &lt;td&gt;SAMx5 bare, Interrupt, DMA ping-pong&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;SAM C2x/D2x&lt;/td&gt;
 &lt;td&gt;SAMC2x, SAMD2x, SAMDA1&lt;/td&gt;
 &lt;td&gt;7&lt;/td&gt;
 &lt;td&gt;SAMx5 implementations (shared)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="block-outputs"&gt;Block Outputs&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Port Name&lt;/th&gt;
 &lt;th&gt;Data Type&lt;/th&gt;
 &lt;th&gt;Size&lt;/th&gt;
 &lt;th&gt;Description&lt;/th&gt;
 &lt;th&gt;Optional&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;Nbr&lt;/td&gt;
 &lt;td&gt;uint8/uint16&lt;/td&gt;
 &lt;td&gt;Scalar&lt;/td&gt;
 &lt;td&gt;Number of bytes received (buffer fill level)&lt;/td&gt;
 &lt;td&gt;Yes (enable via Flag_Out parameter)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Rx&lt;/td&gt;
 &lt;td&gt;uint8&lt;/td&gt;
 &lt;td&gt;Scalar or Vector [N]&lt;/td&gt;
 &lt;td&gt;Received data (configurable size)&lt;/td&gt;
 &lt;td&gt;No (always present)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="configuration-parameters"&gt;Configuration Parameters&lt;/h2&gt;
&lt;h3 id="uart-selection"&gt;UART Selection&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;UART Module&lt;/strong&gt; - Select UART/USART number (must match UART Config block)&lt;/li&gt;
&lt;li&gt;Dropdown automatically populated with available UARTs from selected chip&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="output-size-configuration"&gt;Output Size Configuration&lt;/h3&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Parameter&lt;/th&gt;
 &lt;th&gt;Options&lt;/th&gt;
 &lt;th&gt;Description&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;Rx_Size_popup&lt;/td&gt;
 &lt;td&gt;User defined&lt;/td&gt;
 &lt;td&gt;Inherited via back propagation&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Rx_Size&lt;/td&gt;
 &lt;td&gt;Positive integer or []&lt;/td&gt;
 &lt;td&gt;User-defined size (when Rx_Size_popup = &amp;ldquo;User defined&amp;rdquo;)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="size-determination-methods"&gt;Size Determination Methods&lt;/h3&gt;
&lt;h4 id="1-user-defined"&gt;1. User Defined&lt;/h4&gt;
&lt;p&gt;Explicitly set output vector size:&lt;/p&gt;</description></item><item><title>UART Tx Block</title><link>/block_reference/communication/uart/uart_tx.html</link><pubDate>Thu, 16 Oct 2025 00:00:00 +0000</pubDate><guid>/block_reference/communication/uart/uart_tx.html</guid><description>&lt;div class="block-icon-container"&gt;
 &lt;picture class="block-icon-image"&gt;
 &lt;source srcset="../../assets/images/blocks/bus_uart/UART_Tx.svg" type="image/svg+xml"&gt;
 &lt;img src="../../assets/images/blocks/bus_uart/UART_Tx.png" alt="UART Tx Block Icon"&gt;
 &lt;/picture&gt;
 &lt;div class="block-icon-description"&gt;
 UART_Tx Block Icon The &lt;strong&gt;UART Tx&lt;/strong&gt; block transmits data through a configured UART module. This block sends 8-bit data (uint8 type) and supports variable-length transmission with optional feedback on bytes sent. It works in conjunction with the &lt;strong&gt;UART Config&lt;/strong&gt; block to provide flexible, efficient serial transmission.
 &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="supported-device-families"&gt;Supported Device Families&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Family&lt;/th&gt;
 &lt;th&gt;Series&lt;/th&gt;
 &lt;th&gt;Architecture ID&lt;/th&gt;
 &lt;th&gt;Implementation Files&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;dsPIC&lt;/td&gt;
 &lt;td&gt;30F, 24F, 33F, 33E, 33C, 33A&lt;/td&gt;
 &lt;td&gt;1, 2, 3, 4, 8&lt;/td&gt;
 &lt;td&gt;PIC bare, Interrupt, DMA variants&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;PIC32&lt;/td&gt;
 &lt;td&gt;MK, MZ, MX, PIC32A&lt;/td&gt;
 &lt;td&gt;Included in dsPIC arch&lt;/td&gt;
 &lt;td&gt;Same as dsPIC (PIC implementations)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;SAM E7x/S7x&lt;/td&gt;
 &lt;td&gt;SAME70, SAMS70, V71, PIC32CZ MC70&lt;/td&gt;
 &lt;td&gt;5&lt;/td&gt;
 &lt;td&gt;SAMx7 bare, Interrupt, DMA ping-pong&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;SAM E5x/D5x&lt;/td&gt;
 &lt;td&gt;SAME5x, SAMD5x&lt;/td&gt;
 &lt;td&gt;6&lt;/td&gt;
 &lt;td&gt;SAMx5 bare, Interrupt, DMA ping-pong&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;SAM C2x/D2x&lt;/td&gt;
 &lt;td&gt;SAMC2x, SAMD2x, SAMDA1&lt;/td&gt;
 &lt;td&gt;7&lt;/td&gt;
 &lt;td&gt;SAMx5 implementations (shared)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="block-inputs-and-outputs"&gt;Block Inputs and Outputs&lt;/h2&gt;
&lt;h3 id="inputs"&gt;Inputs&lt;/h3&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Port Name&lt;/th&gt;
 &lt;th&gt;Data Type&lt;/th&gt;
 &lt;th&gt;Description&lt;/th&gt;
 &lt;th&gt;Optional&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;N&lt;/td&gt;
 &lt;td&gt;uint8/uint16&lt;/td&gt;
 &lt;td&gt;Number of bytes to send (variable length mode)&lt;/td&gt;
 &lt;td&gt;Yes (enable via parameter)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Tx&lt;/td&gt;
 &lt;td&gt;uint8 (vector or scalar)&lt;/td&gt;
 &lt;td&gt;Data to transmit&lt;/td&gt;
 &lt;td&gt;No (always present)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;$&lt;/td&gt;
 &lt;td&gt;any&lt;/td&gt;
 &lt;td&gt;Function-Call input (triggers execution)&lt;/td&gt;
 &lt;td&gt;Yes (based on ordering)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="outputs"&gt;Outputs&lt;/h3&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Port Name&lt;/th&gt;
 &lt;th&gt;Data Type&lt;/th&gt;
 &lt;th&gt;Description&lt;/th&gt;
 &lt;th&gt;Optional&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;N&lt;/td&gt;
 &lt;td&gt;uint8/uint16&lt;/td&gt;
 &lt;td&gt;Number of bytes actually sent&lt;/td&gt;
 &lt;td&gt;Yes (enable via parameter)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;$&lt;/td&gt;
 &lt;td&gt;function-call&lt;/td&gt;
 &lt;td&gt;Function-Call output (execution chain)&lt;/td&gt;
 &lt;td&gt;Yes (based on ordering)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="configuration-parameters"&gt;Configuration Parameters&lt;/h2&gt;
&lt;h3 id="uart-selection"&gt;UART Selection&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;UART Module&lt;/strong&gt; - Select UART/USART number (must match UART Config block)&lt;/li&gt;
&lt;li&gt;Dropdown automatically populated with available UARTs from selected chip&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="data-transmission-options"&gt;Data Transmission Options&lt;/h3&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Parameter&lt;/th&gt;
 &lt;th&gt;Options&lt;/th&gt;
 &lt;th&gt;Description&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;NSend Input&lt;/td&gt;
 &lt;td&gt;On/Off checkbox&lt;/td&gt;
 &lt;td&gt;Enable &amp;lsquo;N&amp;rsquo; input port for variable-length transmission&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;NSend Output&lt;/td&gt;
 &lt;td&gt;On/Off checkbox&lt;/td&gt;
 &lt;td&gt;Enable &amp;lsquo;N&amp;rsquo; output port (bytes actually sent)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;UART String Mode&lt;/td&gt;
 &lt;td&gt;On/Off checkbox&lt;/td&gt;
 &lt;td&gt;When enabled: &amp;lsquo;0&amp;rsquo; (null character) marks end of string&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;All or Nothing&lt;/td&gt;
 &lt;td&gt;On/Off checkbox&lt;/td&gt;
 &lt;td&gt;Only transmit if entire buffer can be sent (no partial sends)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="implementation-modes"&gt;Implementation Modes&lt;/h2&gt;
&lt;p&gt;Transmission behavior depends on the implementation mode selected in the &lt;strong&gt;UART Config&lt;/strong&gt; block:&lt;/p&gt;</description></item><item><title>UART TxMatlab Block</title><link>/block_reference/communication/uart/uart_txmatlab.html</link><pubDate>Thu, 16 Oct 2025 00:00:00 +0000</pubDate><guid>/block_reference/communication/uart/uart_txmatlab.html</guid><description>&lt;div class="block-icon-container"&gt;
 &lt;picture class="block-icon-image"&gt;
 &lt;source srcset="../../assets/images/blocks/bus_uart/UART_TxMatlab.svg" type="image/svg+xml"&gt;
 &lt;img src="../../assets/images/blocks/bus_uart/UART_TxMatlab.png" alt="UART TxMatlab Block Icon"&gt;
 &lt;/picture&gt;
 &lt;div class="block-icon-description"&gt;
 UART_TxMatlab Block Icon The &lt;strong&gt;UART TxMatlab&lt;/strong&gt; block transmits numerical data through UART to MATLAB (or alternative hosts) for real-time monitoring, plotting, and recording. This block supports multiple data types (int8, uint8, int16, uint16, int32, uint32, single, double) and implements a packetized protocol for reliable data streaming and visualization using the &lt;strong&gt;picgui&lt;/strong&gt; MATLAB interface.
 &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="supported-device-families"&gt;Supported Device Families&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Family&lt;/th&gt;
 &lt;th&gt;Series&lt;/th&gt;
 &lt;th&gt;Architecture ID&lt;/th&gt;
 &lt;th&gt;Implementation&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;dsPIC&lt;/td&gt;
 &lt;td&gt;30F, 24F, 33F, 33E, 33C, 33A&lt;/td&gt;
 &lt;td&gt;1, 2, 3, 4, 8&lt;/td&gt;
 &lt;td&gt;Same as UART Tx (PIC implementations)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;PIC32&lt;/td&gt;
 &lt;td&gt;MK, MZ, MX, PIC32A&lt;/td&gt;
 &lt;td&gt;Included in dsPIC arch&lt;/td&gt;
 &lt;td&gt;Same as UART Tx (PIC implementations)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;SAM E7x/S7x&lt;/td&gt;
 &lt;td&gt;SAME70, SAMS70, V71, PIC32CZ MC70&lt;/td&gt;
 &lt;td&gt;5&lt;/td&gt;
 &lt;td&gt;USART/UART variants (SAMx7)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;SAM E5x/D5x&lt;/td&gt;
 &lt;td&gt;SAME5x, SAMD5x&lt;/td&gt;
 &lt;td&gt;6&lt;/td&gt;
 &lt;td&gt;SERCOM USART (SAMx5)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;SAM C2x/D2x&lt;/td&gt;
 &lt;td&gt;SAMC2x, SAMD2x, SAMDA1&lt;/td&gt;
 &lt;td&gt;7&lt;/td&gt;
 &lt;td&gt;SERCOM USART (SAMx5 variant)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="block-inputs"&gt;Block Inputs&lt;/h2&gt;
&lt;h3 id="dynamic-channel-inputs"&gt;Dynamic Channel Inputs&lt;/h3&gt;
&lt;p&gt;The number and labels of input ports are determined by the &lt;strong&gt;CHANNELS&lt;/strong&gt; parameter. Each specified channel creates a corresponding input port.&lt;/p&gt;</description></item><item><title>I2C Master/Slave - Communication Blocks</title><link>/block_reference/communication/i2c.html</link><pubDate>Thu, 16 Oct 2025 00:00:00 +0000</pubDate><guid>/block_reference/communication/i2c.html</guid><description>&lt;h2 id="i2c-masterslave-block"&gt;I2C Master/Slave Block&lt;/h2&gt;
&lt;div style="text-align: center; margin: 20px 0;"&gt;
 &lt;picture&gt;
 &lt;source srcset="../../assets/images/blocks/bus_i2c/BUS_I2C_MASTER.svg" type="image/svg+xml"&gt;
 &lt;img src="../../assets/images/blocks/bus_i2c/BUS_I2C_MASTER.png" alt="I2C Block" style="max-width: 200px;"&gt;
 &lt;/picture&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Status&lt;/strong&gt;: Documentation in progress.&lt;/p&gt;
&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;Configure and use I2C (Inter-Integrated Circuit) communication interface in either Master or Slave mode.&lt;/p&gt;
&lt;p&gt;The I2C protocol is a synchronous, multi-master, multi-slave, packet-switched, single-ended serial communication bus commonly used for attaching lower-speed peripheral ICs to processors and microcontrollers. This single block handles both Master and Slave functionality.&lt;/p&gt;
&lt;h2 id="block-modes"&gt;Block Modes&lt;/h2&gt;
&lt;h3 id="master-mode"&gt;Master Mode&lt;/h3&gt;
&lt;p&gt;In Master mode, the microcontroller initiates all communication on the I2C bus:&lt;/p&gt;</description></item><item><title>SPI Master/Slave - Communication Blocks</title><link>/block_reference/communication/spi.html</link><pubDate>Thu, 16 Oct 2025 00:00:00 +0000</pubDate><guid>/block_reference/communication/spi.html</guid><description>&lt;h2 id="spi-masterslave-block"&gt;SPI Master/Slave Block&lt;/h2&gt;
&lt;div style="text-align: center; margin: 20px 0;"&gt;
 &lt;picture&gt;
 &lt;source srcset="../../assets/images/blocks/bus_spi/BUS_SPI.svg" type="image/svg+xml"&gt;
 &lt;img src="../../assets/images/blocks/bus_spi/BUS_SPI.png" alt="SPI Block" style="max-width: 200px;"&gt;
 &lt;/picture&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Status&lt;/strong&gt;: Documentation in progress.&lt;/p&gt;
&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;Configure and use SPI (Serial Peripheral Interface) communication in either Master or Slave mode.&lt;/p&gt;
&lt;p&gt;The SPI protocol is a synchronous serial communication interface for short-distance communication, primarily used in embedded systems. SPI operates in full-duplex mode with a master-slave architecture. This single block handles both Master and Slave functionality.&lt;/p&gt;
&lt;h2 id="block-modes"&gt;Block Modes&lt;/h2&gt;
&lt;h3 id="master-mode"&gt;Master Mode&lt;/h3&gt;
&lt;p&gt;In Master mode, the microcontroller controls the SPI bus:&lt;/p&gt;</description></item></channel></rss>